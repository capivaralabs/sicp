# 1. Construindo Abstrações com procedimentos

> Os atos da mente, que exercem poder sobre ideias simples, são principalmente três:  
> 1. Combinando várias idéias simples para formar uma composta, originando, assim, todas as idéias complexas.  
> 2. Reunindo duas idéias (simples ou complexas), e regulando-as reciprocamente a fim de ter imediatamente uma visão delas, sem, contudo, unificá-las numa, obtendo por este meio todas as suas idéias de relações.  
> 3. Separando-as de todas as outras idéias que lhes estão incorporadas em sua existência real mediante a abstração; deste modo a mente forma todas as suas idéias gerais  
> John Locke, Ensaio Acerca do Entendimento Humano (1690), Tradução de Anoar Aiex

Estamos prestes a estudar a ideia de um processo computacional. Os processos computacionais são seres abstratos que habitam os computadores. A medida que evoluem, os processos manipulam outras coisas abstratas chamadas dados. A evolução de um processo é direcionada por padrões de regras chamado programa. Pessoas criam programa para direcionar processos. Com efeito, conjuramos os espiritos do computador com nossos feitiços.

Um processo computacional é de fato muito parecido a ideia de um espírito conjurado por um feiticeiro. Não pode ser visto ou tocado. Não é nem de longe composto de matéria. No entando, é muito real. Pode realizar trabalho intelectual. Pode responder perguntas. Pode afetar o mundo desembolsando dinheiro em um banco ou controlando braços robos em uma fabrica. Os programas que usamos para conjurar processos são como feitiços de feiticeiros. Eles são cuidadosamente compostos de expressões simbolicas em linguagens de programação arcanas e esotéricas que prescrevam as tarefas que queremos que nossos processos façam.

Um processo computacional, em um computador funcionando corretamente, executa programas com precisão e exatidão. Assim, como o aprendiz de feiticeiro, os programadores novatos devem aprender a compreender e antecipar as conseqüências de sua conjuração. Mesmo pequenos erros (geralmente chamados de bugs ou falhas) nos programas podem ter consequências complexas e imprevistas.

Felizmente, aprender programar é consideravelmente menos perigoso do que aprender feitiçaria, porque os espíritos com os quais lidamos estão convenientemente contidos de maneira segura. A programação do mundo real, no entando, precisa de cuidado, perícia e sabedoria. Um pequeno bug no design de seu programa, por exemplo, pode levar ao colapso catastrófico de um avião ou represa ou a autodestruição de um robo industrial.

Os mestres engenheiros de software tem a habilidade de organizar programas de modo que possam estar razoavelmente seguros de que os processos resultantes executarão as tarefas pretendidas. Eles podem visualizar o comportamento de seus sistemas antecipadamente. Eles sabem como estruturar programas para que problemas imprevistos não levem a consequências castratóficas e, quando surgem problemas, eles podem debugar seus programas. Sistemas computacionais bem projetados, como automóveis bem projetados ou reatores nucleares, são projetados de maneira modular, para que as peças possam ser construídas, substituídas e depuradas separadamente.

## Programação em Lisp

Precisamos de uma linguagme apropriada para descrever processos, e usaremos para isso a linguagem de programação Lisp. Assim como nossos pensamentos cotidianos são geralmente expressos em nossa linguagem natural (como Português, Inglês or Japonês), e as descrições de fenômenos quantitativos são expressas com notações matemáticas, nossos pensamentos procedurais serão expressos em Lisp. Lisp foi inventado no final de 1950 com um formalismo para o raciocínio sobre o uso de certos tipos de expressões lógicas, chamadas de equações de recursão, como um modelo para computação. A linguagem foi concebida por John McCarthy e é baseada em seu artigo `Recursive Functions of Symbolic Expressions and Their Computation by Machine (McCarthy 1960)`

The first Lisp interpreter was implemented by McCarthy with the help of colleagues and students in the Artificial Intelligence Group of the MIT Research Laboratory of Electronics and in the MIT Computation Center.1 Lisp, whose name is an acronym for LISt Processing, was designed to provide symbol-manipulating capabilities for attacking programming problems such as the symbolic differentiation and integration of algebraic expressions. It included for this purpose new data objects known as atoms and lists, which most strikingly set it apart from all other languages of the period.

Apesar de seu início como um formalismo matemático, o Lisp é uma linguagem de programação prática. Um interpretador Lisp é uma máquina que executa processos descritos na linguagem Lisp. O primeiro interpretador Lisp foi implementado por McCarthy com a ajuda de colegas e alunos do Grupo de Inteligência Artificial do Laboratório de Eletrônica de Pesquisa do MIT e do Centro de Computação do MIT. Lisp, cujo nome é um acrônimo para Processamento de lista(LISt Processing), foi projetado para fornecer recursos de manipulação de símbolos para atacar problemas de programação, como a diferenciação simbólica e a integração de expressões algébricas. Incluía para este propósito novos objetos de dados, conhecidos como átomos e listas, que, de maneira mais impressionante, o diferenciavam de todas as outras línguas do período.

Lisp não foi o produto de um esforço de design combinado. Em vez disso, evoluiu informalmente de maneira experimental em resposta as necessidades dos usuários e as considerações de implementação pragmática. A evolução informal de Lisp continuou ao longo dos anos, e os usuários da comunidade Lisp tradicionalmente resistiram as tentativas de promulgar qualquer definição "oficial" do idioma. Esta evolução, juntamente com a flexibilidade e elegância da consepção inicial, permitiu que Lisp, que é a segunda lingua mais antiga em uso generalizado hoje (apenas Fortran é mais antigo), se adpte continuamente para abranger as idéias mais modernas sobre o design do programa. Assim, Lisp é agora uma família de dialetos que, embora compartilhem a maioria das características originais, podem diferir uns dos outros de maneiras significativas. O dialeto de lisp usado neste livro é chamado Scheme.

Por causa de seu caráter experimental e sua ênfase na manipulação de símbolos, Lisp foi inicialmente muito ineficiente para cálculos numéricos, pelo menos em comparação com Fortran. Ao longo dos anos, no entanto, foram desenvolvidos compiladores Lisp que convertem programas em códigos de máquina que podem executar cálculos numéricos de forma razoavelmente eficiente. E para aplicações especiais, o Lisp foi usado com grande eficácia. Embora o Lisp ainda não tenha superado sua antiga reputação como irremediavelmente ineficiente, o Lisp agora é usado em muitas aplicações onde a eficiência não é a preocupação central. Por exemplo, o Lisp se tornou um idioma de escolha para linguagens shell de sistema operacional e para idiomas de extensão para editores e sistemas de design auxiliados por computador.

Se Lisp não é uma linguagem mainstream, por que estamos usando isso como a estrutura para nossa discussão sobre programação? Porque a linguagem possui características únicas que a tornam um excelente meio para estudar importantes construções de programação e estruturas de dados e para relacioná-las às características lingüísticas que as suportam. O mais significativo desses recursos é o fato de que as descrições de processos do Lisp, chamadas procedures, podem ser representadas e manipuladas como dados do Lisp. A importância disso é que existem técnicas poderosas de design de programas que dependem da capacidade de desfocar a distinção tradicional entre dados ``passivos`` e processos ``ativos``. Como veremos, a flexibilidade de Lisp em lidar com procedimentos como dados faz com que seja uma das linguagens mais convenientes para explorar essas técnicas. A capacidade de representar procedimentos como dados também torna o Lisp uma excelente linguagem para escrever programas que devem manipular outros programas como dados, como os interpretadores e compiladores que suportam linguagens de computador. Acima e além dessas considerações, a programação em Lisp é muito divertida.
